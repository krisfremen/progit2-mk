[[_credential_caching]]
=== Складирање на ингеренции

(((credentials)))
(((git commands, credential)))
Ако го користите транспортот за SSH за поврзување со далечински управувачи, можно е да имате клуч без тајна фраза, која овозможува безбедно пренесување на податоци без напишување на вашето корисничко име и лозинка.
Сепак, ова не е можно со HTTP протоколите - секоја врска му треба корисничко име и лозинка.
Ова станува уште потешко за системи со двофакторска автентикација, каде токен што го користите за лозинка е случајно генерирана и непроверлива.

За среќа, Git има систем за проверка на квалификации кој може да помогне во тоа.
Git има неколку опции наведени во полето:

* Стандардното не е да се кешира воопшто.
  Секоја конекција ќе ве прашува за вашето корисничко име и лозинка.
* Режимот `` кеш '' ги задржува акредитивите во меморијата за одреден временски период.
  Ниту една од лозинките никогаш не е зачувана на дискот, и тие се очисти од кешот по 15 минути.
* Режимот `` store '' ги зачувува акредитивните писма на обичен текстуален фајл на дискот и никогаш не истекуваат.
  Ова значи дека додека не ја смените лозинката за домаќинот Git, никогаш нема да морате повторно да ги внесувате вашите ингеренции.
  Недостатоци на овој пристап е дека вашите лозинки се зачувани во чист текст во обична датотека во вашиот домашен директориум.
* Ако користите Mac, Git доаѓа со `` osxkeychain '' режим, кој ги кешира акредитивните писма во безбедносниот приврзок со клучеви кој е прикачен на вашата системска сметка.
  Овој метод ги зачувува ингеренциите на дискот и тие никогаш не истекуваат, но тие се шифрирани со истиот систем кој ги зачувува HTTPS-сертификатите и авто-пополнувањата на Safari.
* Ако користите Windows, можете да инсталирате помошник наречен `` Git Credential Manager for Windows. ''
  Ова е слично на помошник "osxkeychain", кој е опишан погоре, но го користи Продавницата за Credential на Windows за да ги контролира чувствителните информации.
  Може да се најдат на https://github.com/Microsoft/Git-Credential-Manager-for-Windows [].

Можете да изберете еден од овие методи со поставување на вредноста на конфигурацијата Git:

[source,console]
----
$ git config --global credential.helper cache
----

Некои од овие помошници имаат опции.
Помошник за "чување" може да земе аргумент `--file <path>`, кој се прилагодува каде што е зачувана обичната текстуална датотека (стандардно е `~ / .git-credentials`).
Помошник за "кеш" ја прифаќа опцијата `--timeout <seconds>`, која го менува времето во кое неговиот демон продолжува да работи (стандардно е `` 900 '' или 15 минути).
Еве еден пример за тоа како би го конфигурирале помошникот "чувар" со сопствено име на датотека:

[source,console]
----
$ git config --global credential.helper 'store --file ~/.my-credentials'
----

Git дури и ви овозможува да конфигурирате неколку помошници.
Кога барате ингеренциите за одреден домаќин, Git ќе ги побара по редослед и ќе застане откако ќе биде обезбеден првиот одговор.
Кога ги зачувувате ингеренциите, Git ќе го испрати корисничкото име и лозинката на * сите * на помошниците во листата, и тие можат да изберат што да прават со нив.
Еве што ќе изгледа како ".gitconfig" ако сте имале датотека со сертификат за патеката, но сакавте да го користите кешот во меморијата за да зачувате некое пишување ако уредот не е вклучен:

[source,ini]
----
[credential]
    helper = store --file /mnt/thumbdrive/.git-credentials
    helper = cache --timeout 30000
----

==== Под хаубата

Како функционира сето ова?
Коректната команда на Git за системот за проверка на привилегиите е `git credential`, која зема команда како аргумент, а потоа повеќе влез преку stdin.

Ова може да биде полесно да се разбере со пример.
Да речеме дека помошник за проверка е конфигуриран, а помошникот ги зачувал акредитивните писма за `mygithost`.
Еве една сесија која ја користи командата `` fill '', која се повикува кога Git се обидува да најде ингеренции за домаќин:

[source,console]
----
$ git credential fill <1>
protocol=https <2>
host=mygithost
<3>
protocol=https <4>
host=mygithost
username=bob
password=s3cre7
$ git credential fill <5>
protocol=https
host=unknownhost

Username for 'https://unknownhost': bob
Password for 'https://bob@unknownhost':
protocol=https
host=unknownhost
username=bob
password=s3cre7
----

<1> Ова е командната линија што ја иницира интеракцијата.
<2> Git-credential потоа чека на внесување на stdin.
     Ние им го обезбедуваме она што го знаеме: протоколот и името на домаќинот.
<3> Празна линија покажува дека влезот е завршен, а системот за проверка треба да одговори на она што го знае.
<4> Git-credential потоа презема, и пишува да stdout со делови од информации што ги најде.
<5> Ако не се најдат ингеренциите, Git го прашува корисникот за корисничкото име и лозинката, и ги враќа назад до повикувачкиот stdout (тука се прикачени кон истата конзола).

Системот на акредитиви всушност се повикува на програма која е одделена од самата Git; кој еден и како зависи од "credential.helper" конфигурациската вредност.
Постојат неколку форми што може да ги преземе:

[options="header"]
|======
| Configuration Value | Behavior
| `foo` | Runs `git-credential-foo`
| `foo -a --opt=bcd` | Runs `git-credential-foo -a --opt=bcd`
| `/absolute/path/foo -xyz` | Runs `/absolute/path/foo -xyz`
| `!f() { echo "password=s3cre7"; }; f` | Code after `!` evaluated in shell
|======

Значи помошниците опишани погоре се всушност именувани како "git-credential-cache", "git-credential-store" и така натаму, и можеме да ги конфигурираме да ги преземеме командните аргументи.
Општата форма за ова е `` git-credential-foo [args] <action>. ''
Протоколот stdin / stdout е ист како git-ингеренција, но тие користат нешто различно множество акции:

* `get` е барање за пар на корисничко име / лозинка.
* `store` е барање за зачувување на збир на ингеренциите во меморијата на овој помошник.
* "Избриши" исчистете ги ингеренциите за дадените својства од меморијата на овој помошник.

За постапките `store` и` erase`, не е потребен одговор (Git тоа го игнорира).
За `get` акцијата, сепак, Git е многу заинтересиран за она што помошникот има да каже.
Ако помошникот не знае ништо корисно, едноставно може да излезе без излез, но ако знае, треба да ги зголеми информациите што ги обезбедил со информациите што ги има складирано.
Излезот се третира како серија на извештаи за доделување; сè што е предвидено ќе го замени она што Гит веќе го знае.

Еве го истиот пример од погоре, но прескокнувајќи го Git-акредитив и одејќи директно за Git-credential-store:

[source,console]
----
$ git credential-store --file ~/git.store store <1>
protocol=https
host=mygithost
username=bob
password=s3cre7
$ git credential-store --file ~/git.store get <2>
protocol=https
host=mygithost

username=bob <3>
password=s3cre7
----

<1> Овде кажуваме `git-credential-store` за да зачуваме некои ингеренции: корисничкото име` `bob '' и лозинката` `s3cre7 '' треба да се користат кога се пристапува на" https: // mygithost ".
<2> Сега ќе ги добиеме овие ингеренции.
     Обезбедуваме делови од врската што веќе ја познаваме (`https: // mygithost`) и празна линија.
<3> одговори на `git-credential-store` со корисничкото име и лозинката што ги сочувавме погоре.

Еве што изгледа датотеката `~ / git.store`:

[source,ini]
----
https://bob:s3cre7@mygithost
----

Тоа е само серија на линии, од кои секоја содржи URL адреса украсени со акредитиви.
`Osxkeychain` и` wincred` помагачите го користат оригиналниот формат на нивните продавници за поддршка, додека `cache` го користи својот сопствен формат во меморијата (што не може да се чита од друг процес).

==== Кеш на прилагодено уверение

Со оглед на тоа дека `git-credential-store` и пријателите се посебни програми од Git, тоа не е голем скок за да сфатиме дека _any_ програмата може да биде помошник за Git.
Помошниците обезбедени од Git покриваат многу случаи на честа употреба, но не сите.
На пример, да речеме дека вашиот тим има некои ингеренции кои се делат со целиот тим, можеби за распоредување.
Овие се зачувани во споделен директориум, но не сакате да ги копирате во сопствената продавница за акредитиви, бидејќи често се менуваат.
Ниту еден од постојните помошници не го покрива овој случај; да видиме што ќе биде потребно за да напишеме.
Постојат неколку клучни карактеристики кои треба да ги има оваа програма:

. Единствената акција на која треба да обрнеме внимание е `get`; `store` и` erase` се операции за запишување, па ние само ќе излеземе чисто кога ќе бидат примени.
. Форматот на датотека на датотеката со споделени сертификати е ист како оној што го користи `git-credential-store`.
. Локацијата на таа датотека е прилично стандардна, но ние треба да му дозволиме на корисникот да помине сопствен пат за секој случај.

Уште еднаш, ќе го напишеме ова проширување во Ruby, но секој јазик ќе работи се додека Git може да го изврши готовиот производ.
Еве го целиот изворниот код на нашиот нов акредитивен помошник:

[source,ruby]
--------
include::../git-credential-read-only[]
--------

<1> Овде ги разгледуваме опциите на командната линија, овозможувајќи му на корисникот да ја специфицира влезната датотека. Стандардно е `~ / .git-credentials`.
<2> Оваа програма реагира само ако дејството е `get` и постои датотека со резервни копии.
<3> Оваа јамка чита од Stdin додека не се постигне првата празна линија.
     Влезовите се зачувани во `позната` хаш за подоцнежна референца.
<4> Оваа јамка ја чита содржината на датотеката за складирање, барајќи натпревари.
     Ако протоколот и домаќин од "познат" се совпаѓаат со оваа линија, програмата ги печати резултатите во stdout и излегува.

Ние ќе го спасиме нашиот помошник како `git-credential-read-only`, ставете го некаде во нашата` PATH` и означете го извршна.
Еве как изгледа интерактивна сесија:

[source,console]
----
$ git credential-read-only --file=/mnt/shared/creds get
protocol=https
host=mygithost

protocol=https
host=mygithost
username=bob
password=s3cre7
----

Бидејќи неговото име започнува со `` git- '', можеме да ја користиме едноставната синтакса за конфигурациската вредност:

[source,console]
----
$ git config --global credential.helper 'read-only --file /mnt/shared/creds'
----

Како што можете да видите, проширувањето на овој систем е прилично едноставно и може да реши некои заеднички проблеми за вас и за вашиот тим.
